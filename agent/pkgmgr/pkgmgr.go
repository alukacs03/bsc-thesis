package pkgmgr

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"log"
	"os"
	"os/exec"
	"strings"
)

const (
	frrRepoURL            = "https://deb.frrouting.org/frr"
	frrRepoListPath       = "/etc/apt/sources.list.d/frr.list"
	frrKeyringPath        = "/usr/share/keyrings/frrouting.gpg"
	frrKeyURL             = "https://deb.frrouting.org/frr/keys.gpg"
	defaultDebianCodename = "bookworm"
	frrDaemonsPath        = "/etc/frr/daemons"
)

var aptUpdated bool

func EnsureDependencies(ctx context.Context) error {
	if os.Geteuid() != 0 {
		return errors.New("package installation requires root privileges")
	}

	if err := ensureWireGuard(ctx); err != nil {
		return fmt.Errorf("wireguard dependency: %w", err)
	}

	if err := ensureFRR(ctx); err != nil {
		return fmt.Errorf("frr dependency: %w", err)
	}

	return nil
}

func ensureWireGuard(ctx context.Context) error {
	if commandExists("wg") && commandExists("wg-quick") {
		return nil
	}

	log.Println("WireGuard not detected, installing wireguard + wireguard-tools...")
	if err := aptUpdate(ctx); err != nil {
		return err
	}

	return aptInstall(ctx, "wireguard", "wireguard-tools")
}

func ensureFRR(ctx context.Context) error {
	if commandExists("vtysh") || pkgInstalled(ctx, "frr") {
		return nil
	}

	log.Println("FRR not detected, installing from FRRouting repository...")

	if err := ensureFRRRepo(ctx); err != nil {
		return err
	}

	if err := aptUpdate(ctx); err != nil {
		return err
	}

	if err := aptInstall(ctx, "frr", "frr-pythontools"); err != nil {
		return err
	}

	if err := configureFRRDaemons(); err != nil {
		return err
	}
	if _, err := runCommand(ctx, "systemctl", "enable", "--now", "frr"); err != nil {
		return err
	}
	if _, err := runCommand(ctx, "systemctl", "restart", "frr"); err != nil {
		return err
	}

	return nil
}

func ensureFRRRepo(ctx context.Context) error {
	repoExists := fileExists(frrRepoListPath)

	codename := strings.TrimSpace(string(commandOutput(ctx, "lsb_release", "-s", "-c")))
	if codename == "" {
		codename = defaultDebianCodename
	}

	keyBytes := commandOutput(ctx, "curl", "-fsSL", frrKeyURL)
	if len(keyBytes) == 0 {
		keyBytes = commandOutput(ctx, "wget", "-qO-", frrKeyURL)
	}
	if len(keyBytes) == 0 {
		return fmt.Errorf("failed to download FRR key from %s", frrKeyURL)
	}

	if err := os.WriteFile(frrKeyringPath, keyBytes, 0644); err != nil {
		return fmt.Errorf("write keyring: %w", err)
	}

	if !repoExists {
		repoLine := fmt.Sprintf("deb [signed-by=%s] %s %s frr-stable\n", frrKeyringPath, frrRepoURL, codename)
		if err := os.WriteFile(frrRepoListPath, []byte(repoLine), 0644); err != nil {
			return fmt.Errorf("write repo list: %w", err)
		}
	}

	log.Printf("Added FRR APT repo for %s", codename)
	return nil
}

func pkgInstalled(ctx context.Context, pkg string) bool {
	cmd := exec.CommandContext(ctx, "dpkg-query", "-W", "-f=${Status}", pkg)
	output, err := cmd.Output()
	if err != nil {
		return false
	}
	return strings.Contains(string(output), "install ok installed")
}

func aptUpdate(ctx context.Context) error {
	if aptUpdated {
		return nil
	}

	if _, err := runCommand(ctx, "apt-get", "update"); err != nil {
		return err
	}
	aptUpdated = true
	return nil
}

func aptInstall(ctx context.Context, pkgs ...string) error {
	args := append([]string{"install", "-y"}, pkgs...)
	_, err := runCommand(ctx, "apt-get", args...)
	return err
}

func commandExists(name string) bool {
	_, err := exec.LookPath(name)
	return err == nil
}

func commandOutput(ctx context.Context, name string, args ...string) []byte {
	out, err := exec.CommandContext(ctx, name, args...).Output()
	if err != nil {
		return nil
	}
	return out
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func configureFRRDaemons() error {
	desired := map[string]string{
		"ospfd": "yes",
	}

	current := map[string]string{}
	var lines []string
	if fileExists(frrDaemonsPath) {
		data, err := os.ReadFile(frrDaemonsPath)
		if err != nil {
			return err
		}
		for _, line := range strings.Split(string(data), "\n") {
			trim := strings.TrimSpace(line)
			if strings.HasPrefix(trim, "#") || !strings.Contains(trim, "=") {
				lines = append(lines, line)
				continue
			}
			parts := strings.SplitN(trim, "=", 2)
			key := parts[0]
			val := parts[1]
			current[key] = val
			if desiredVal, ok := desired[key]; ok && val != desiredVal {
				line = fmt.Sprintf("%s=%s", key, desiredVal)
			}
			lines = append(lines, line)
		}
	} else {
		lines = []string{
			"# Autogenerated by gluon-agent",
			"bgpd=no",
			"ospfd=yes",
			"ospf6d=no",
			"ripd=no",
			"ripngd=no",
			"isisd=no",
			"pimd=no",
			"pim6d=no",
			"ldpd=no",
			"nhrpd=no",
			"eigrpd=no",
			"babeld=no",
			"sharpd=no",
			"pbrd=no",
			"bfdd=no",
			"fabricd=no",
			"vrrpd=no",
			"pathd=no",
		}
	}

	for k, v := range desired {
		if cur, ok := current[k]; !ok || cur != v {
			lines = append(lines, fmt.Sprintf("%s=%s", k, v))
		}
	}

	content := strings.Join(lines, "\n") + "\n"
	if err := os.WriteFile(frrDaemonsPath, []byte(content), 0644); err != nil {
		return err
	}
	return nil
}

func runCommand(ctx context.Context, name string, args ...string) ([]byte, error) {
	cmd := exec.CommandContext(ctx, name, args...)
	cmd.Env = append(os.Environ(), "DEBIAN_FRONTEND=noninteractive")

	var buf bytes.Buffer
	cmd.Stdout = &buf
	cmd.Stderr = &buf

	err := cmd.Run()
	if err != nil {
		return buf.Bytes(), fmt.Errorf("%s %s failed: %w - %s", name, strings.Join(args, " "), err, buf.String())
	}

	return buf.Bytes(), nil
}
